<!DOCTYPE html>
<html>
<body style="font-family:Arial;padding:20px;">

<h2>Webcam Streaming Control</h2>

<label>Stream Key:</label><br>
<input id="streamKey" type="text" style="width:300px;"><br><br>

<label>Role:</label><br>
<select id="role" style="width:200px;">
    <option value="broadcaster">broadcaster</option>
    <option value="audio_only">audio_only</option>
</select><br><br>

<button id="startBtn">Start Stream</button>
<button id="stopBtn" disabled>Stop Stream</button>

<hr>

<video id="cam" autoplay playsinline style="width:60%;border:1px solid #ccc;"></video>

<hr>

<h3>Log</h3>
<div id="log" style="
    width:80%;
    height:200px;
    background:#111;
    color:#0f0;
    padding:10px;
    overflow-y:auto;
    font-family:monospace;
    font-size:14px;
"></div>

<script>
let ws = null;
let recorder = null;
let stream = null;
let reconnectTimer = null;
let pc = null; // WebRTC fallback

function log(msg) {
    const logBox = document.getElementById("log");
    logBox.innerText += msg + "\n";
    logBox.scrollTop = logBox.scrollHeight;
}

// WebSocket connection with TLS (WSS) and auto-reconnect
async function connectWS(key, role) {
    const wsUrl = `wss://world.tsunamiflow.club:8443?key=${encodeURIComponent(key)}&role=${encodeURIComponent(role)}`;
    ws = new WebSocket(wsUrl);
    ws.binaryType = "arraybuffer";

    ws.onopen = () => {
        log("üåê WebSocket connected.");
        document.getElementById("startBtn").disabled = true;
        document.getElementById("stopBtn").disabled = false;
        if (reconnectTimer) clearTimeout(reconnectTimer);
    };

    ws.onclose = () => {
        log("‚ö†Ô∏è WebSocket closed. Reconnecting in 3s...");
        reconnectTimer = setTimeout(() => connectWS(key, role), 3000);
    };

    ws.onerror = SomethingError;

function SomethingError(err) {
log("‚ùå WebSocket error: " + err);

if (err instanceof Event) {
 log("Event Type:" err.type);
}
}

    ws.onmessage = event => {
        try {
            const data = JSON.parse(event.data);
            if (data.type === "ffmpeg_stderr") log("[FFmpeg] " + data.message);
        } catch {
            // ignore non-JSON (binary) messages
        }
    };
}

document.getElementById("startBtn").onclick = async function () {
    const key = document.getElementById("streamKey").value.trim();
    const role = document.getElementById("role").value;
    if (!key) { alert("Enter a stream key."); return; }

    // Get camera/microphone
    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: role !== "audio_only",
            audio: role !== "audio_only"
        });
        document.getElementById("cam").srcObject = stream;
    } catch (err) {
        log("‚ùå Failed to access camera/mic: " + err);
        return;
    }

    // Attempt WebSocket streaming first
    try {
        await connectWS(key, role);

        recorder = new MediaRecorder(stream, { mimeType: "video/webm; codecs=vp8" });
        recorder.ondataavailable = e => {
            if (e.data.size > 0 && ws.readyState === 1) {
                e.data.arrayBuffer().then(buf => ws.send(buf));
            }
        };
        recorder.start(100);
        log("üöÄ Streaming started via WebSocket.");
    } catch (err) {
        log("‚ö†Ô∏è WebSocket failed, falling back to WebRTC: " + err);
        startWebRTC(stream);
    }
};

document.getElementById("stopBtn").onclick = function () {
    if (recorder) { recorder.stop(); log("üõë Recorder stopped."); }
    if (ws && ws.readyState === 1) { ws.send(JSON.stringify({ type: "stop_stream" })); ws.close(); }
    if (stream) { stream.getTracks().forEach(t => t.stop()); log("üì∑ Camera stopped."); }
    if (pc) { pc.close(); pc = null; log("üîó WebRTC stopped."); }

    document.getElementById("startBtn").disabled = false;
    document.getElementById("stopBtn").disabled = true;
};

// WebRTC fallback (minimal placeholder)
async function startWebRTC(localStream) {
    pc = new RTCPeerConnection();
    pc.onicecandidate = e => {
        if (e.candidate) log("ICE candidate: " + JSON.stringify(e.candidate));
    };
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        log("üìù WebRTC offer created. Send SDP to server for connection.");
    } catch (err) {
        log("‚ùå WebRTC error: " + err);
    }
}
</script>
</body>
</html>