export class StripeDonation {
    constructor(stripePublicKey, backendUrl = "https://world.tsunamiflow.club/StripeStuff.php") {
        this.stripe = Stripe(stripePublicKey);
        this.backendUrl = backendUrl;
        this.cardElement = null;
        this.customerId = localStorage.getItem('stripeCustomerId') || null; // saved customer
    }

    request(data) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", this.backendUrl, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.withCredentials = true;
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        if (xhr.status === 200 && !response.error) resolve(response);
                        else reject(response.error || 'Unknown error');
                    } catch (err) {
                        reject(err.message || 'JSON parse error');
                    }
                }
            };
            xhr.send(JSON.stringify(data));
        });
    }

    mountCard(elementId) {
        const elements = this.stripe.elements();
        this.cardElement = elements.create('card');
        this.cardElement.mount(`#${elementId}`);
    }

    // Donate (one-time) with optional saved customer
    async donate(amount, currency = 'usd', saveCustomer = true, email = null) {
        if (!this.cardElement) throw new Error("Card element not mounted");

        const payload = {
            action: 'createPaymentIntent',
            amount: Math.round(amount * 100),
            currency,
            saveCustomer: saveCustomer,
            email: email
        };

        if (this.customerId) payload.customerId = this.customerId;

        const data = await this.request(payload);
        const { clientSecret, customerId } = data;

        if (saveCustomer && customerId) this.customerId = customerId;
        if (customerId) localStorage.setItem('stripeCustomerId', customerId);

        return this.stripe.confirmCardPayment(clientSecret, {
            payment_method: { card: this.cardElement }
        });
    }

    // Subscribe (recurring) with optional saved customer
    async subscribe(email, priceId, saveCustomer = true) {
        if (!this.cardElement) throw new Error("Card element not mounted");

        const payload = {
            action: 'createSubscription',
            email,
            priceId,
            saveCustomer: saveCustomer
        };

        if (this.customerId) payload.customerId = this.customerId;

        const data = await this.request(payload);
        const { clientSecret, subscriptionId, customerId } = data;

        if (saveCustomer && customerId) this.customerId = customerId;
        if (customerId) localStorage.setItem('stripeCustomerId', customerId);

        if (!clientSecret) {
            return { status: 'success', message: 'No payment required', subscriptionId };
        }

        return this.stripe.confirmCardPayment(clientSecret, {
            payment_method: { card: this.cardElement }
        });
    }

    getClientSecret(action, data) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", this.backendUrl, true);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.withCredentials = true;
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        if (xhr.status === 200 && !response.error) resolve(response.clientSecret);
                        else reject(response.error || 'Unknown error');
                    } catch (err) {
                        reject(err.message || 'JSON parse error');
                    }
                }
            };
            xhr.send(JSON.stringify({ action, ...data }));
        });
    }
}